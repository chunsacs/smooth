{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///Smooth.min.js","webpack:///webpack/bootstrap 42927a26f9cccab1f143","webpack:///./src/smooth.js","webpack:///./~/raf/index.js","webpack:///./~/performance-now/lib/performance-now.js","webpack:///./~/process/browser.js","webpack:///./~/vendor-prefix/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","raf","prefix","transform","dash","transition","Smooth","VERSION","opt","arguments","undefined","handlers","run","debounce","resize","perfs","now","last","vars","preload","current","height","documentHeight","bounding","timer","ticking","firstFrame","ticketScroll","smoothContainer","smoothSection","el","document","body","animation","transformType","axis","ease","initialValue","dom","fakeDiv","elementsParallaxe","elementsTrigger","preloadImages","addEvents","reflow","element","animations","push","trigger","triggered","elements","addElement","addElements","startValue","findStart","endValue","findEnd","images","Array","slice","querySelectorAll","forEach","image","img","Image","onload","splice","indexOf","bind","src","getAttribute","clearTimeout","classList","add","setTimeout","remove","window","scrollY","pageYOffset","addScrollingClass","updatesmoothContainer","old","updateParallaxeElements","checkTriggerElements","notScrolling","done","properties","computeTransformStyle","setStyle","frame","index","j","before","after","edge","transformDone","indexTransform","transformAnimation","finalValue","computeClassicStyle","progress","Math","min","max","currentValue","isInit","reset","initialStyles","finalStyles","style","tfAnimation","smoothValue","roundedValue","round","property","noParsing","parseStyle","opacity","parsedStyle","currentProperty","x","y","z","both","elem","finalStyle","duration","easing","delay","console","log","addEventListener","removeEventListener","cancel","parentNode","removeChild","position","width","createElement","className","insertBefore","nextSibling","bodyRect","getBoundingClientRect","elemRect","offset","top","start","getOffset","elementHeight","offsetHeight","windowHeight","factor","viewFactorStart","isNaN","positionTop","parseInt","end","viewFactorEnd","positionBottom","array","counter","Number","MAX_VALUE","a","html","documentElement","scrollHeight","clientHeight","l","getPositionStart","getPositionEnd","setTransformSequence","k","initialValues","finalValues","animationObject","generateTransition","addFakeScrollHeight","addFakeHeight","innerHeight","clientWidth","innerWidth","getDocumentHeight","removeFakeScrollHeight","removeFakeHeight","removeEvents","default","global","vendors","suffix","caf","queue","frameDuration","callback","_now","next","cp","cancelled","e","handle","fn","apply","polyfill","requestAnimationFrame","cancelAnimationFrame","process","getNanoSeconds","hrtime","loadTime","performance","hr","Date","getTime","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","runClearTimeout","marker","cachedClearTimeout","cleanUpNextTick","draining","currentQueue","concat","queueIndex","drainQueue","timeout","len","Item","noop","nextTick","args","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","name","cwd","chdir","dir","umask","get","memo","capitalizedKey","replace","s","match","toUpperCase","prefixes","capitalize","str","charAt","dashedPrefix","prefixedKey","upper","test","hasPrefix","toLowerCase","split"],"mappings":"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","file":"Smooth.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Smooth\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Smooth\"] = factory();\n\telse\n\t\troot[\"Smooth\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Smooth\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Smooth\"] = factory();\n\telse\n\t\troot[\"Smooth\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\t\tvalue: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar raf = __webpack_require__(1);\n\tvar prefix = __webpack_require__(4);\n\tvar transform = prefix.dash('transform');\n\tvar transition = prefix.dash('transition');\n\t\n\t/*!\n\t * smooth core\n\t *\n\t * Tim Roussilhe\n\t *\n\t * Free to use under terms of MIT license\n\t */\n\t\n\t/*!\n\t\n\t */\n\t\n\tvar Smooth = function () {\n\t\t\t/*\n\t   * Global api.\n\t   */\n\t\n\t\t\tfunction Smooth() {\n\t\t\t\t\t_classCallCheck(this, Smooth);\n\t\n\t\t\t\t\tthis.VERSION = '0.0.1';\n\t\n\t\t\t\t\tvar opt = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t\t\t\t\tthis.handlers = {\n\t\t\t\t\t\t\trun: null,\n\t\t\t\t\t\t\tdebounce: null,\n\t\t\t\t\t\t\tresize: null\n\t\t\t\t\t};\n\t\n\t\t\t\t\tthis.perfs = {\n\t\t\t\t\t\t\tnow: null,\n\t\t\t\t\t\t\tlast: null\n\t\t\t\t\t};\n\t\n\t\t\t\t\tthis.vars = {\n\t\t\t\t\t\t\tpreload: opt.preload || false,\n\t\t\t\t\t\t\tcurrent: 0,\n\t\t\t\t\t\t\ttarget: 0,\n\t\t\t\t\t\t\theight: 0,\n\t\t\t\t\t\t\tdocumentHeight: 0,\n\t\t\t\t\t\t\tbounding: 0,\n\t\t\t\t\t\t\ttimer: null,\n\t\t\t\t\t\t\tticking: false\n\t\t\t\t\t};\n\t\n\t\t\t\t\t//pony trick here, we remove easing on frist frame to avoid flash or blink or big scroll\n\t\t\t\t\tthis.firstFrame = true;\n\t\n\t\t\t\t\tthis.ticketScroll = false;\n\t\n\t\t\t\t\tthis.smoothContainer = opt.smoothContainer;\n\t\n\t\t\t\t\tif (this.smoothContainer) {\n\t\n\t\t\t\t\t\t\tthis.smoothSection = {\n\t\t\t\t\t\t\t\t\tel: opt.smoothSection ? opt.smoothSection : document.body,\n\t\t\t\t\t\t\t\t\tanimation: {\n\t\t\t\t\t\t\t\t\t\t\ttransform: [{\n\t\t\t\t\t\t\t\t\t\t\t\t\ttransformType: 'translate3d',\n\t\t\t\t\t\t\t\t\t\t\t\t\taxis: 'y',\n\t\t\t\t\t\t\t\t\t\t\t\t\tease: 0.15,\n\t\t\t\t\t\t\t\t\t\t\t\t\tinitialValue: 0\n\t\t\t\t\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\n\t\t\t\t\t//lister is use for smooth scrolling container\n\t\t\t\t\tthis.dom = document.body;\n\t\t\t\t\tthis.fakeDiv = null;\n\t\n\t\t\t\t\tthis.elementsParallaxe = [];\n\t\t\t\t\tthis.elementsTrigger = [];\n\t\n\t\t\t\t\tthis.resize();\n\t\t\t}\n\t\n\t\t\t_createClass(Smooth, [{\n\t\t\t\t\tkey: 'init',\n\t\t\t\t\tvalue: function init() {\n\t\n\t\t\t\t\t\t\tthis.vars.preload && this.preloadImages();\n\t\n\t\t\t\t\t\t\tthis.addEvents();\n\t\n\t\t\t\t\t\t\t!this.vars.preload && this.resize();\n\t\t\t\t\t}\n\t\t\t}, {\n\t\t\t\t\tkey: 'start',\n\t\t\t\t\tvalue: function start() {\n\t\t\t\t\t\t\tthis.reflow();\n\t\t\t\t\t\t\tthis.raf = raf(this.handlers.run);\n\t\t\t\t\t}\n\t\t\t}, {\n\t\t\t\t\tkey: 'addElement',\n\t\t\t\t\tvalue: function addElement(element) {\n\t\n\t\t\t\t\t\t\tif (element.animations !== undefined) {\n\t\n\t\t\t\t\t\t\t\t\tthis.elementsParallaxe.push(element);\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif (element.trigger !== undefined) {\n\t\n\t\t\t\t\t\t\t\t\telement.triggered = false;\n\t\t\t\t\t\t\t\t\tthis.elementsTrigger.push(element);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}, {\n\t\t\t\t\tkey: 'addElements',\n\t\t\t\t\tvalue: function addElements(elements) {\n\t\n\t\t\t\t\t\t\tfor (var i = 0; i < elements.length; i++) {\n\t\n\t\t\t\t\t\t\t\t\tthis.addElement(elements[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//In case we wanna add dynamic value from the instaciation of the parent resize\n\t\n\t\t\t}, {\n\t\t\t\t\tkey: 'resetElements',\n\t\t\t\t\tvalue: function resetElements(elements) {\n\t\n\t\t\t\t\t\t\tthis.elementsParallaxe = [];\n\t\t\t\t\t\t\tthis.elementsTrigger = [];\n\t\n\t\t\t\t\t\t\tthis.addElements(elements);\n\t\t\t\t\t\t\tthis.reflow();\n\t\t\t\t\t}\n\t\t\t\t\t//If an object as several transform we need extra work ( thanks you css !)\n\t\n\t\t\t}, {\n\t\t\t\t\tkey: 'setTransformSequence',\n\t\t\t\t\tvalue: function setTransformSequence(animation) {\n\t\n\t\t\t\t\t\t\tanimation.startValue = this.findStart(animation.transform);\n\t\t\t\t\t\t\tanimation.endValue = this.findEnd(animation.transform);\n\t\t\t\t\t}\n\t\t\t}, {\n\t\t\t\t\tkey: 'preloadImages',\n\t\t\t\t\tvalue: function preloadImages() {\n\t\n\t\t\t\t\t\t\tvar images = Array.prototype.slice.call(this.dom.querySelectorAll('img'), 0);\n\t\n\t\t\t\t\t\t\timages.forEach(function (image) {\n\t\n\t\t\t\t\t\t\t\t\tvar img = new Image();\n\t\n\t\t\t\t\t\t\t\t\timg.onload = function (el) {\n\t\n\t\t\t\t\t\t\t\t\t\t\timages.splice(images.indexOf(image), 1);\n\t\t\t\t\t\t\t\t\t\t\timages.length === 0 && this.resize();\n\t\t\t\t\t\t\t\t\t}.bind(this);\n\t\n\t\t\t\t\t\t\t\t\timg.src = image.getAttribute('src');\n\t\t\t\t\t\t\t}.bind(this));\n\t\t\t\t\t}\n\t\t\t}, {\n\t\t\t\t\tkey: 'debounce',\n\t\t\t\t\tvalue: function debounce() {\n\t\n\t\t\t\t\t\t\tthis.ticketScroll = true;\n\t\t\t\t\t}\n\t\t\t}, {\n\t\t\t\t\tkey: 'addScrollingClass',\n\t\t\t\t\tvalue: function addScrollingClass() {\n\t\n\t\t\t\t\t\t\tclearTimeout(this.vars.timer);\n\t\n\t\t\t\t\t\t\tif (!this.vars.ticking) {\n\t\t\t\t\t\t\t\t\tthis.vars.ticking = true;\n\t\n\t\t\t\t\t\t\t\t\tthis.dom.classList.add('is-scrolling');\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tthis.vars.timer = setTimeout(function () {\n\t\t\t\t\t\t\t\t\tthis.vars.ticking = false;\n\t\n\t\t\t\t\t\t\t\t\tthis.dom.classList.remove('is-scrolling');\n\t\t\t\t\t\t\t}.bind(this), 200);\n\t\t\t\t\t}\n\t\t\t}, {\n\t\t\t\t\tkey: 'run',\n\t\t\t\t\tvalue: function run() {\n\t\n\t\t\t\t\t\t\tif (this.ticketScroll) {\n\t\n\t\t\t\t\t\t\t\t\tthis.vars.target = window.scrollY || window.pageYOffset;\n\t\t\t\t\t\t\t\t\tthis.addScrollingClass();\n\t\t\t\t\t\t\t\t\tthis.ticketScroll = false;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// this.vars.current += (this.vars.target - this.vars.current) * this.vars.ease;\n\t\t\t\t\t\t\tthis.vars.current = this.vars.target;\n\t\t\t\t\t\t\tthis.vars.current < .1 && (this.vars.current = 0);\n\t\n\t\t\t\t\t\t\t// If we are having a global smooth container\n\t\t\t\t\t\t\t// Animate it following scroll position of dom\n\t\t\t\t\t\t\tif (this.smoothContainer) this.updatesmoothContainer(this.vars.current === this.vars.old);\n\t\n\t\t\t\t\t\t\t//Still not sure why i pass frame here since we register this globaly...\n\t\t\t\t\t\t\tthis.updateParallaxeElements(this.vars.current, this.vars.current === this.vars.old);\n\t\t\t\t\t\t\tif (this.vars.current != this.vars.old) this.checkTriggerElements(this.vars.current);\n\t\n\t\t\t\t\t\t\tthis.vars.old = this.vars.current;\n\t\n\t\t\t\t\t\t\t//this.rAF = requestAnimationFrame(this.run.bind(this));\n\t\t\t\t\t\t\tthis.raf = raf(this.handlers.run);\n\t\t\t\t\t}\n\t\t\t}, {\n\t\t\t\t\tkey: 'updatesmoothContainer',\n\t\t\t\t\tvalue: function updatesmoothContainer(notScrolling) {\n\t\n\t\t\t\t\t\t\tif (!this.smoothSection.animation.transform[0].done || !notScrolling) {\n\t\n\t\t\t\t\t\t\t\t\tthis.smoothSection.animation.properties = [];\n\t\t\t\t\t\t\t\t\t//so far we only allow one transform on the body (x or y)\n\t\t\t\t\t\t\t\t\tthis.computeTransformStyle(this.smoothSection.animation, this.smoothSection.animation.transform[0], -this.vars.current);\n\t\n\t\t\t\t\t\t\t\t\tthis.setStyle(this.smoothSection.el, this.smoothSection.animation.properties);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/**\n\t    * Update all Elements\n\t    * Edge Management\n\t    */\n\t\n\t\t\t}, {\n\t\t\t\t\tkey: 'updateParallaxeElements',\n\t\t\t\t\tvalue: function updateParallaxeElements(frame, notScrolling) {\n\t\n\t\t\t\t\t\t\tvar index = 0;\n\t\t\t\t\t\t\tfor (; index < this.elementsParallaxe.length; index++) {\n\t\n\t\t\t\t\t\t\t\t\tvar element = this.elementsParallaxe[index];\n\t\t\t\t\t\t\t\t\tvar properties = [];\n\t\n\t\t\t\t\t\t\t\t\tfor (var j = 0; j < element.animations.length; j++) {\n\t\n\t\t\t\t\t\t\t\t\t\t\tvar animation = element.animations[j];\n\t\t\t\t\t\t\t\t\t\t\tvar before = frame < animation.startValue;\n\t\t\t\t\t\t\t\t\t\t\tvar after = frame > animation.endValue;\n\t\n\t\t\t\t\t\t\t\t\t\t\t//create a new array to catch all properties related to the same el\n\t\t\t\t\t\t\t\t\t\t\tanimation.properties = [];\n\t\n\t\t\t\t\t\t\t\t\t\t\t//If we are before/after the first/`last frame, set the styles according first/last value.\n\t\t\t\t\t\t\t\t\t\t\tif (before || after) {\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t//we are at firt or last and allready setStyle to reach initial/final Value\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (before && animation.edge === -1 || after && animation.edge === 1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (animation.done) continue;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tanimation.edge = before ? -1 : 1;\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (animation.transform) {\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//We need to check that all subAnimation are done so we use this as a flag\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar transformDone = true;\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var indexTransform = 0; indexTransform < animation.transform.length; indexTransform++) {\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar transformAnimation = animation.transform[indexTransform];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.computeTransformStyle(animation, transformAnimation, animation.edge === -1 ? transformAnimation.initialValue : transformAnimation.finalValue);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (transformAnimation.done === false) transformDone = false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//no we check the flag\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// if one of the subAnimation is not done the flag will be false\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// // if all done then the main animation is done\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (transformDone === true) {\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tanimation.done = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tanimation.done = false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.computeClassicStyle(animation, animation.edge === -1 ? animation.initialValue : animation.finalValue);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t//now we have array of properties we gonna parse them and apply them\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (animation.properties.length > 0) this.setStyle(element.el, animation.properties);\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (animation.done && animation.edge === 0 && notScrolling) continue;\n\t\t\t\t\t\t\t\t\t\t\t\t\tanimation.edge = 0;\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t//We need to check that all subAnimation are done so we use this as a flag\n\t\t\t\t\t\t\t\t\t\t\t\t\tvar transformDone = true;\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (animation.transform) {\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var indexTransform = 0; indexTransform < animation.transform.length; indexTransform++) {\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar transformAnimation = animation.transform[indexTransform];\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Cap progress between 0 and 1 ( Mostly because of transform sequences )\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar progress = Math.min(Math.max((frame - transformAnimation.startValue) / (transformAnimation.endValue - transformAnimation.startValue), 0), 1);\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//TODO ADD EASING\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// progress = left.props[key].easing(progress);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar currentValue = transformAnimation.initialValue + (transformAnimation.finalValue - transformAnimation.initialValue) * progress;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.computeTransformStyle(animation, transformAnimation, currentValue);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (transformAnimation.done === false) transformDone = false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//no we check the flag\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// if one of the subAnimation is not done the flag will be false\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// if all done then the main animation is done\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (transformDone === true) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tanimation.done = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tanimation.done = false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar progress = (frame - animation.startValue) / (animation.endValue - animation.startValue);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar currentValue = animation.initialValue + (animation.finalValue - animation.initialValue) * progress;\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.computeClassicStyle(animation, currentValue);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t// now we have array of properties we gonna parse them and apply them\n\t\t\t\t\t\t\t\t\t\t\t\t\t// we are doing this one per animation not once per element\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (animation.properties.length > 0) this.setStyle(element.el, animation.properties);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}, {\n\t\t\t\t\tkey: 'checkTriggerElements',\n\t\t\t\t\tvalue: function checkTriggerElements(frame) {\n\t\n\t\t\t\t\t\t\tvar index = 0;\n\t\t\t\t\t\t\tfor (; index < this.elementsTrigger.length; index++) {\n\t\n\t\t\t\t\t\t\t\t\tvar element = this.elementsTrigger[index];\n\t\t\t\t\t\t\t\t\tvar before = frame < element.startValue;\n\t\n\t\t\t\t\t\t\t\t\t//add css transition and trigger first position\n\t\t\t\t\t\t\t\t\tif (!element.isInit) {\n\t\n\t\t\t\t\t\t\t\t\t\t\tthis.setStyle(element.el, element.transition, true);\n\t\t\t\t\t\t\t\t\t\t\telement.isInit = true;\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t// So far we are not using after for the trigger\n\t\t\t\t\t\t\t\t\tif (before) {\n\t\n\t\t\t\t\t\t\t\t\t\t\tif (before && element.edge === -1) continue;\n\t\n\t\t\t\t\t\t\t\t\t\t\telement.edge = before ? -1 : 1;\n\t\n\t\t\t\t\t\t\t\t\t\t\t// if we are going back before trigger point\n\t\t\t\t\t\t\t\t\t\t\t// triggered = false\n\t\t\t\t\t\t\t\t\t\t\tif (element.trigger.reset) {\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0; i < element.initialStyles.length; i++) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.setStyle(element.el, element.initialStyles[i], true);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\telement.triggered = false;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else if (!element.triggered) {\n\t\n\t\t\t\t\t\t\t\t\t\t\telement.edge = 0;\n\t\t\t\t\t\t\t\t\t\t\telement.triggered = true;\n\t\n\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0; i < element.finalStyles.length; i++) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.setStyle(element.el, element.finalStyles[i].style, true);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//OUTPUT\n\t\n\t\t\t}, {\n\t\t\t\t\tkey: 'computeTransformStyle',\n\t\t\t\t\tvalue: function computeTransformStyle(animation, tfAnimation, value) {\n\t\n\t\t\t\t\t\t\t//We calculate smooth value here if easing\n\t\t\t\t\t\t\t//here means first fucking frame\n\t\t\t\t\t\t\tif (tfAnimation.smoothValue === undefined) {\n\t\t\t\t\t\t\t\t\ttfAnimation.smoothValue = tfAnimation.initialValue;\n\t\t\t\t\t\t\t\t\ttfAnimation.smoothValue += value - tfAnimation.smoothValue;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttfAnimation.smoothValue += (value - tfAnimation.smoothValue) * tfAnimation.ease;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tvar roundedValue = Math.round(tfAnimation.smoothValue * 1000) / 1000;\n\t\n\t\t\t\t\t\t\t//checking if animation of transform value is done\n\t\t\t\t\t\t\t//check if animation is done comparing the final value to the rounded one\n\t\t\t\t\t\t\t// we need to round the final value too to be able to compate to roundedValue\n\t\t\t\t\t\t\tif (Math.round(value * 1000) / 1000 === roundedValue) tfAnimation.done = true;else tfAnimation.done = false;\n\t\n\t\t\t\t\t\t\t//We check if there is allready a transform in the main animation\n\t\t\t\t\t\t\tif (animation.properties) {\n\t\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < animation.properties.length; i++) {\n\t\n\t\t\t\t\t\t\t\t\t\t\t//Case for transform\n\t\t\t\t\t\t\t\t\t\t\tif (animation.properties[i].property === tfAnimation.transformType) {\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tanimation.properties[i][tfAnimation.axis] = roundedValue;\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t//If there is no transform we create the object\n\t\t\t\t\t\t\tvar style = {\n\t\t\t\t\t\t\t\t\tproperty: tfAnimation.transformType\n\t\t\t\t\t\t\t};\n\t\n\t\t\t\t\t\t\tstyle[tfAnimation.axis] = roundedValue;\n\t\n\t\t\t\t\t\t\t//push value to parent animation\n\t\t\t\t\t\t\tanimation.properties.push(style);\n\t\t\t\t\t}\n\t\t\t}, {\n\t\t\t\t\tkey: 'computeClassicStyle',\n\t\t\t\t\tvalue: function computeClassicStyle(animation, value) {\n\t\n\t\t\t\t\t\t\t//We calculate smooth value here if easing\n\t\t\t\t\t\t\t//here means first fucking frame so no easing to avoid blick/flash etc\n\t\t\t\t\t\t\tif (animation.smoothValue === undefined) {\n\t\t\t\t\t\t\t\t\tanimation.smoothValue = animation.initialValue;\n\t\t\t\t\t\t\t\t\tanimation.smoothValue += value - animation.smoothValue;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tanimation.smoothValue += (value - animation.smoothValue) * animation.ease;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tvar roundedValue = Math.round(animation.smoothValue * 100) / 100;\n\t\n\t\t\t\t\t\t\tvar style = {\n\t\t\t\t\t\t\t\t\tproperty: animation.property,\n\t\t\t\t\t\t\t\t\tvalue: roundedValue\n\t\t\t\t\t\t\t};\n\t\n\t\t\t\t\t\t\t//check if animation is done comparing the final value to the rounded one\n\t\t\t\t\t\t\t// we need to round the final value too to be able to compate to roundedValue\n\t\t\t\t\t\t\tif (Math.round(value * 100) / 100 === roundedValue) animation.done = true;else animation.done = false;\n\t\n\t\t\t\t\t\t\t//save property into animation object\n\t\t\t\t\t\t\tanimation.properties.push(style);\n\t\t\t\t\t}\n\t\n\t\t\t\t\t/**\n\t    * Set Future Style\n\t    * Element is here to pass el of current Element\n\t    * Animation is current animation of element ( need to be precised because it can be several ones )\n\t    * Value is current scroll value ( need to be calculated before ) Here we just apply momemtum is ease < 1\n\t    */\n\t\t\t\t\t//rounded number\n\t\t\t\t\t//https://jsperf.com/parsefloat-tofixed-vs-math-round\n\t\n\t\t\t}, {\n\t\t\t\t\tkey: 'setStyle',\n\t\t\t\t\tvalue: function setStyle(el, style, noParsing) {\n\t\n\t\t\t\t\t\t\tif (!noParsing) var style = this.parseStyle(style);\n\t\n\t\t\t\t\t\t\tif (style[0] === 'transform') {\n\t\t\t\t\t\t\t\t\tel.style[transform] = style[1];\n\t\t\t\t\t\t\t} else if (style[0] === 'opacity') {\n\t\t\t\t\t\t\t\t\tel.style.opacity = style[1];\n\t\t\t\t\t\t\t} else if (style[0] === 'transition') {\n\t\t\t\t\t\t\t\t\tel.style[transition] = style[1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// return an object containing all style\n\t\t\t\t\t// ====>\n\t\t\t\t\t// Example Object {transform: \"translate3d(66.5px,66.5px,0) scale3d(1.06,1.06,1)\"}\n\t\t\t\t\t// ====>\n\t\n\t\t\t}, {\n\t\t\t\t\tkey: 'parseStyle',\n\t\t\t\t\tvalue: function parseStyle(properties) {\n\t\t\t\t\t\t\t// could use regexpt and a pattern here but want to avoid replace inside raf\n\t\t\t\t\t\t\t// so we chose switch and string concatenation\n\t\t\t\t\t\t\t// also useful if we want to add more control here such as translate or translate3d... background color calculcation etc\n\t\t\t\t\t\t\t// https://jsperf.com/string-concat-vs-regex-replace/2\n\t\n\t\t\t\t\t\t\t//TODO Centralize Animations when severals animations and at the end set all style\n\t\t\t\t\t\t\t// AND return all\n\t\t\t\t\t\t\tvar parsedStyle = [];\n\t\n\t\t\t\t\t\t\tfor (var i = 0; i < properties.length; i++) {\n\t\n\t\t\t\t\t\t\t\t\tvar currentProperty = properties[i];\n\t\t\t\t\t\t\t\t\tswitch (currentProperty.property) {\n\t\n\t\t\t\t\t\t\t\t\t\t\tcase 'translate3d':\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tvar x = currentProperty.x ? currentProperty.x + 'px' : 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\tvar y = currentProperty.y ? currentProperty.y + 'px' : 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\tvar z = currentProperty.z ? currentProperty.z + 'px' : 0;\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t//parsedStyle['transform'] ? parsedStyle['transform'] += ' translate3d('+ x +','+ y +','+ z +')' : parsedStyle[\"transform\"] = 'translate3d('+ x +','+ y +','+ z +')';\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (parsedStyle[0] === 'transform') {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tparsedStyle[1] += ' translate3d(' + x + ',' + y + ',' + z + ')';\n\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tparsedStyle[0] = 'transform';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tparsedStyle[1] = 'translate3d(' + x + ',' + y + ',' + z + ')';\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase 'scale3d':\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tvar x = currentProperty.x || currentProperty.both ? currentProperty.x || currentProperty.both : 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\tvar y = currentProperty.y || currentProperty.both ? currentProperty.y || currentProperty.both : 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\tvar z = currentProperty.z ? currentProperty.z + 'px' : 1;\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t//parsedStyle[\"transform\"] ?  parsedStyle[\"transform\"] += ' scale3d('+ x +','+ y +','+ z +')' : parsedStyle[\"transform\"] = 'scale3d('+ x +','+ y +','+ z +')'\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (parsedStyle[0] === 'transform') {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tparsedStyle[1] += ' scale3d(' + x + ',' + y + ',' + z + ')';\n\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tparsedStyle[0] = 'transform';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tparsedStyle[1] = 'scale3d(' + x + ',' + y + ',' + z + ')';\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase 'rotate3d':\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tvar x = currentProperty.x || currentProperty.both ? currentProperty.x || currentProperty.both : 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\tvar y = currentProperty.y || currentProperty.both ? currentProperty.y || currentProperty.both : 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\tvar z = currentProperty.z ? currentProperty.z + 'px' : 1;\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t//parsedStyle[\"transform\"] = parsedStyle[\"transform\"] = 'rotate('+currentProperty.y+'deg)'\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (parsedStyle[0] === 'transform') {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tparsedStyle[1] += ' rotate(' + x + ',' + y + ',' + z + ')';\n\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tparsedStyle[0] = 'transform';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tparsedStyle[1] = 'rotate(' + x + ',' + y + ',' + z + ')';\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase 'opacity':\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (parsedStyle.length > 0) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tparsedStyle.push('opacity');\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tparsedStyle.push(currentProperty.value);\n\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tparsedStyle[0] = 'opacity';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tparsedStyle[1] = currentProperty.value;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\treturn parsedStyle;\n\t\t\t\t\t}\n\t\t\t}, {\n\t\t\t\t\tkey: 'generateTransition',\n\t\t\t\t\tvalue: function generateTransition(elem) {\n\t\n\t\t\t\t\t\t\tvar transition = [];\n\t\t\t\t\t\t\ttransition[0] = 'transition';\n\t\t\t\t\t\t\ttransition[1] = '';\n\t\n\t\t\t\t\t\t\t//We decided to check final styles value to add proper properties ( also initial state can be set in CSS too)\n\t\t\t\t\t\t\tfor (var i = 0; i < elem.finalStyles.length; i++) {\n\t\n\t\t\t\t\t\t\t\t\tvar finalStyle = elem.finalStyles[i];\n\t\t\t\t\t\t\t\t\ttransition[1] += finalStyle.style[0] + ' ' + finalStyle.duration / 1000 + 's ' + finalStyle.easing + ' ' + finalStyle.delay / 1000 + 's';\n\t\n\t\t\t\t\t\t\t\t\tif (i != elem.finalStyles.length - 1) {\n\t\t\t\t\t\t\t\t\t\t\ttransition[1] += ' , ';\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\treturn transition;\n\t\t\t\t\t}\n\t\t\t}, {\n\t\t\t\t\tkey: 'addEvents',\n\t\t\t\t\tvalue: function addEvents() {\n\t\n\t\t\t\t\t\t\tconsole.log('addEvents this.handlers', this.handlers);\n\t\n\t\t\t\t\t\t\tthis.handlers.debounce = this.debounce.bind(this);\n\t\t\t\t\t\t\t//this.handlers.resize     = this.resize.bind(this);\n\t\t\t\t\t\t\tthis.handlers.run = this.run.bind(this);\n\t\n\t\t\t\t\t\t\twindow.addEventListener('scroll', this.handlers.debounce);\n\t\t\t\t\t\t\t//window.addEventListener('resize', this.handlers.resize);\n\t\t\t\t\t}\n\t\t\t}, {\n\t\t\t\t\tkey: 'removeEvents',\n\t\t\t\t\tvalue: function removeEvents() {\n\t\n\t\t\t\t\t\t\tconsole.log('removeEvents this.handlers', this.handlers);\n\t\n\t\t\t\t\t\t\twindow.removeEventListener('scroll', this.handlers.debounce);\n\t\t\t\t\t\t\t//window.removeEventListener('resize', this.handlers.resize);\n\t\n\t\t\t\t\t\t\traf.cancel(this.raf);\n\t\n\t\t\t\t\t\t\tthis.handlers = {\n\t\t\t\t\t\t\t\t\trun: null,\n\t\t\t\t\t\t\t\t\tdebounce: null,\n\t\t\t\t\t\t\t\t\tresize: null\n\t\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t}, {\n\t\t\t\t\tkey: 'removeFakeScrollHeight',\n\t\t\t\t\tvalue: function removeFakeScrollHeight() {\n\t\n\t\t\t\t\t\t\tthis.fakeDiv.parentNode.removeChild(this.fakeDiv);\n\t\t\t\t\t\t\tthis.fakeDiv = null;\n\t\n\t\t\t\t\t\t\tthis.smoothSection.el.style.position = \"relative\";\n\t\t\t\t\t\t\tthis.smoothSection.el.style.width = \"auto\";\n\t\t\t\t\t\t\tthis.smoothSection.el.style.transform = \"\";\n\t\t\t\t\t}\n\t\t\t}, {\n\t\t\t\t\tkey: 'addFakeScrollHeight',\n\t\t\t\t\tvalue: function addFakeScrollHeight(value) {\n\t\n\t\t\t\t\t\t\tif (this.fakeDiv === null) {\n\t\n\t\t\t\t\t\t\t\t\tthis.fakeDiv = document.createElement(\"div\");\n\t\t\t\t\t\t\t\t\tthis.fakeDiv.className = \"smooth-fake-scroll\";\n\t\t\t\t\t\t\t\t\tthis.fakeDiv.style.height = value + \"px\";\n\t\n\t\t\t\t\t\t\t\t\tthis.smoothSection.el.parentNode.insertBefore(this.fakeDiv, this.smoothSection.el.nextSibling);\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\tthis.fakeDiv.style.height = value + \"px\";\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tthis.smoothSection.el.style.position = \"fixed\";\n\t\t\t\t\t\t\tthis.smoothSection.el.style.width = \"100%\";\n\t\t\t\t\t}\n\t\t\t}, {\n\t\t\t\t\tkey: 'addFakeHeight',\n\t\t\t\t\tvalue: function addFakeHeight(value) {\n\t\n\t\t\t\t\t\t\tthis.dom.style.height = value + 'px';\n\t\t\t\t\t}\n\t\t\t}, {\n\t\t\t\t\tkey: 'removeFakeHeight',\n\t\t\t\t\tvalue: function removeFakeHeight() {\n\t\n\t\t\t\t\t\t\tthis.dom.style.height = 'auto';\n\t\t\t\t\t}\n\t\t\t}, {\n\t\t\t\t\tkey: 'scrollTo',\n\t\t\t\t\tvalue: function scrollTo(value) {\n\t\n\t\t\t\t\t\t\t//TODO ADD COOL SCROLLING AND EASING\n\t\n\t\t\t\t\t}\n\t\t\t}, {\n\t\t\t\t\tkey: 'getOffset',\n\t\t\t\t\tvalue: function getOffset(el) {\n\t\n\t\t\t\t\t\t\tvar bodyRect = this.dom.getBoundingClientRect(),\n\t\t\t\t\t\t\t    elemRect = el.getBoundingClientRect(),\n\t\t\t\t\t\t\t    offset = elemRect.top - bodyRect.top;\n\t\n\t\t\t\t\t\t\treturn offset;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t//here we receive the actual DOM element and the animation\n\t\n\t\t\t}, {\n\t\t\t\t\tkey: 'getPositionStart',\n\t\t\t\t\tvalue: function getPositionStart(el, animation) {\n\t\n\t\t\t\t\t\t\tif (animation.start === 'in-viewport') {\n\t\n\t\t\t\t\t\t\t\t\tvar offset = this.getOffset(el);\n\t\t\t\t\t\t\t\t\tvar elementHeight = el.offsetHeight;\n\t\t\t\t\t\t\t\t\tvar windowHeight = this.vars.height;\n\t\n\t\t\t\t\t\t\t\t\tvar factor = animation.viewFactorStart ? animation.viewFactorStart : 0;\n\t\n\t\t\t\t\t\t\t\t\tif (isNaN(factor) && factor.indexOf('px') !== -1) {\n\t\t\t\t\t\t\t\t\t\t\tvar positionTop = offset - windowHeight + parseInt(animation.viewFactorStart, 10);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tvar positionTop = offset - windowHeight + elementHeight * factor;\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\treturn positionTop > 0 ? positionTop : 0;\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\treturn animation.start;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}, {\n\t\t\t\t\tkey: 'getPositionEnd',\n\t\t\t\t\tvalue: function getPositionEnd(el, animation) {\n\t\n\t\t\t\t\t\t\tif (animation.end === 'out-viewport') {\n\t\n\t\t\t\t\t\t\t\t\tvar offset = this.getOffset(el);\n\t\t\t\t\t\t\t\t\tvar elementHeight = el.offsetHeight;\n\t\t\t\t\t\t\t\t\tvar factor = animation.viewFactorEnd ? animation.viewFactorEnd : 0;\n\t\n\t\t\t\t\t\t\t\t\tvar positionBottom = offset + elementHeight - elementHeight * factor;\n\t\n\t\t\t\t\t\t\t\t\treturn positionBottom > this.vars.documentHeight - this.vars.height ? this.vars.documentHeight - this.vars.height : positionBottom;\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\treturn animation.end;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}, {\n\t\t\t\t\tkey: 'findStart',\n\t\t\t\t\tvalue: function findStart(array) {\n\t\t\t\t\t\t\tvar min = Number.MAX_VALUE,\n\t\t\t\t\t\t\t    a = array.length,\n\t\t\t\t\t\t\t    counter;\n\t\n\t\t\t\t\t\t\tfor (counter = 0; counter < a; counter++) {\n\t\t\t\t\t\t\t\t\tif (array[counter].startValue < min) {\n\t\t\t\t\t\t\t\t\t\t\tmin = array[counter].startValue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\treturn min;\n\t\t\t\t\t}\n\t\t\t}, {\n\t\t\t\t\tkey: 'findEnd',\n\t\t\t\t\tvalue: function findEnd(array) {\n\t\t\t\t\t\t\tvar max = 0,\n\t\t\t\t\t\t\t    a = array.length,\n\t\t\t\t\t\t\t    counter;\n\t\n\t\t\t\t\t\t\tfor (counter = 0; counter < a; counter++) {\n\t\t\t\t\t\t\t\t\tif (array[counter].endValue > max) {\n\t\t\t\t\t\t\t\t\t\t\tmax = array[counter].endValue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\treturn max;\n\t\t\t\t\t}\n\t\t\t}, {\n\t\t\t\t\tkey: 'getDocumentHeight',\n\t\t\t\t\tvalue: function getDocumentHeight() {\n\t\n\t\t\t\t\t\t\tvar body = this.dom,\n\t\t\t\t\t\t\t    html = document.documentElement;\n\t\n\t\t\t\t\t\t\treturn Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);\n\t\t\t\t\t}\n\t\n\t\t\t\t\t//Here we check all element and set their data correctly\n\t\t\t\t\t//Mostly usefull to parse viewport relative timeline\n\t\n\t\t\t}, {\n\t\t\t\t\tkey: 'reflow',\n\t\t\t\t\tvalue: function reflow() {\n\t\n\t\t\t\t\t\t\tvar end = 0;\n\t\n\t\t\t\t\t\t\tfor (var i = 0; i < this.elementsParallaxe.length; i++) {\n\t\n\t\t\t\t\t\t\t\t\tvar element = this.elementsParallaxe[i];\n\t\n\t\t\t\t\t\t\t\t\tfor (var j = 0; j < element.animations.length; j++) {\n\t\n\t\t\t\t\t\t\t\t\t\t\tvar animation = element.animations[j];\n\t\n\t\t\t\t\t\t\t\t\t\t\t//now we check for transform animations array\n\t\t\t\t\t\t\t\t\t\t\tif (animation.transform) {\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var l = 0; l < animation.transform.length; l++) {\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//start for each transfor of the array\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tanimation.transform[l].startValue = this.getPositionStart(element.el, animation.transform[l]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tanimation.transform[l].endValue = this.getPositionEnd(element.el, animation.transform[l]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tanimation.startValue = this.getPositionStart(element.el, animation);\n\t\t\t\t\t\t\t\t\t\t\t\t\tanimation.endValue = this.getPositionEnd(element.el, animation);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\t\t//we build global sequence if there is a timeline of transform\n\t\t\t\t\t\t\t\t\t\t\tif (animation.transform) this.setTransformSequence(animation);\n\t\n\t\t\t\t\t\t\t\t\t\t\tif (animation.endValue > end) end = animation.endValue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tfor (var k = 0; k < this.elementsTrigger.length; k++) {\n\t\n\t\t\t\t\t\t\t\t\tvar element = this.elementsTrigger[k];\n\t\n\t\t\t\t\t\t\t\t\t//here we convert viewport to actual scrolling value if needed\n\t\n\t\t\t\t\t\t\t\t\t//TODO IMPROVE THIS FOR TRIGGER\n\t\t\t\t\t\t\t\t\telement.startValue = this.getPositionStart(element.el, element.trigger);\n\t\n\t\t\t\t\t\t\t\t\t//we need also to define initial and final values here\n\t\t\t\t\t\t\t\t\t//since we just need to applicate them when we reache trigger Y Value\n\t\n\t\t\t\t\t\t\t\t\t//Can be optional if set in CSS\n\t\t\t\t\t\t\t\t\tif (element.trigger.initialValues) {\n\t\t\t\t\t\t\t\t\t\t\telement.initialStyles = [];\n\t\n\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0; i < element.trigger.initialValues.length; i++) {\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tvar value = element.trigger.initialValues[i];\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\telement.initialStyles.push(this.parseStyle(value.animation));\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t//those are required\n\t\t\t\t\t\t\t\t\telement.finalStyles = [];\n\t\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < element.trigger.finalValues.length; i++) {\n\t\n\t\t\t\t\t\t\t\t\t\t\tvar value = element.trigger.finalValues[i];\n\t\n\t\t\t\t\t\t\t\t\t\t\tvar animationObject = {\n\t\t\t\t\t\t\t\t\t\t\t\t\tdelay: value.delay,\n\t\t\t\t\t\t\t\t\t\t\t\t\tduration: value.duration,\n\t\t\t\t\t\t\t\t\t\t\t\t\teasing: value.easing,\n\t\t\t\t\t\t\t\t\t\t\t\t\tstyle: this.parseStyle(value.animation)\n\t\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\t\telement.finalStyles.push(animationObject);\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\telement.transition = this.generateTransition(element);\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t//check to initiate first state if needed\n\t\t\t\t\t\t\tif (this.elementsTrigger.length > 0) this.checkTriggerElements(this.vars.current);\n\t\n\t\t\t\t\t\t\t// Now we computed all start and end of each animation\n\t\t\t\t\t\t\t// we checked if need to add more scroll to be sure that we can display them all.\n\t\t\t\t\t\t\tif (this.smoothContainer) {\n\t\n\t\t\t\t\t\t\t\t\tvar prop = 'height';\n\t\t\t\t\t\t\t\t\tthis.vars.bounding = this.smoothSection.el.getBoundingClientRect().height;\n\t\t\t\t\t\t\t\t\tthis.addFakeScrollHeight(this.vars.bounding);\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif (end > this.vars.documentHeight) this.addFakeHeight(end);\n\t\t\t\t\t}\n\t\t\t}, {\n\t\t\t\t\tkey: 'resize',\n\t\t\t\t\tvalue: function resize() {\n\t\n\t\t\t\t\t\t\tthis.vars.height = document.documentElement.clientHeight || window.innerHeight;\n\t\t\t\t\t\t\tthis.vars.width = document.documentElement.clientWidth || window.innerWidth;\n\t\t\t\t\t\t\tthis.vars.documentHeight = this.getDocumentHeight();\n\t\t\t\t\t\t\tthis.reflow();\n\t\t\t\t\t}\n\t\t\t}, {\n\t\t\t\t\tkey: 'destroy',\n\t\t\t\t\tvalue: function destroy() {\n\t\n\t\t\t\t\t\t\tif (this.fakeDiv) this.removeFakeScrollHeight();\n\t\t\t\t\t\t\tthis.removeFakeHeight();\n\t\t\t\t\t\t\tthis.removeEvents();\n\t\n\t\t\t\t\t\t\tthis.elementsTrigger.length = 0;\n\t\t\t\t\t\t\tthis.elementsTrigger = [];\n\t\n\t\t\t\t\t\t\tthis.elementsParallaxe.length = 0;\n\t\t\t\t\t\t\tthis.elementsParallaxe = [];\n\t\t\t\t\t}\n\t\t\t}]);\n\t\n\t\t\treturn Smooth;\n\t}();\n\t\n\texports.default = Smooth;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {var now = __webpack_require__(2)\n\t  , root = typeof window === 'undefined' ? global : window\n\t  , vendors = ['moz', 'webkit']\n\t  , suffix = 'AnimationFrame'\n\t  , raf = root['request' + suffix]\n\t  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]\n\t\n\tfor(var i = 0; !raf && i < vendors.length; i++) {\n\t  raf = root[vendors[i] + 'Request' + suffix]\n\t  caf = root[vendors[i] + 'Cancel' + suffix]\n\t      || root[vendors[i] + 'CancelRequest' + suffix]\n\t}\n\t\n\t// Some versions of FF have rAF but not cAF\n\tif(!raf || !caf) {\n\t  var last = 0\n\t    , id = 0\n\t    , queue = []\n\t    , frameDuration = 1000 / 60\n\t\n\t  raf = function(callback) {\n\t    if(queue.length === 0) {\n\t      var _now = now()\n\t        , next = Math.max(0, frameDuration - (_now - last))\n\t      last = next + _now\n\t      setTimeout(function() {\n\t        var cp = queue.slice(0)\n\t        // Clear queue here to prevent\n\t        // callbacks from appending listeners\n\t        // to the current frame's queue\n\t        queue.length = 0\n\t        for(var i = 0; i < cp.length; i++) {\n\t          if(!cp[i].cancelled) {\n\t            try{\n\t              cp[i].callback(last)\n\t            } catch(e) {\n\t              setTimeout(function() { throw e }, 0)\n\t            }\n\t          }\n\t        }\n\t      }, Math.round(next))\n\t    }\n\t    queue.push({\n\t      handle: ++id,\n\t      callback: callback,\n\t      cancelled: false\n\t    })\n\t    return id\n\t  }\n\t\n\t  caf = function(handle) {\n\t    for(var i = 0; i < queue.length; i++) {\n\t      if(queue[i].handle === handle) {\n\t        queue[i].cancelled = true\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tmodule.exports = function(fn) {\n\t  // Wrap in a new function to prevent\n\t  // `cancel` potentially being assigned\n\t  // to the native rAF function\n\t  return raf.call(root, fn)\n\t}\n\tmodule.exports.cancel = function() {\n\t  caf.apply(root, arguments)\n\t}\n\tmodule.exports.polyfill = function() {\n\t  root.requestAnimationFrame = raf\n\t  root.cancelAnimationFrame = caf\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {// Generated by CoffeeScript 1.7.1\n\t(function() {\n\t  var getNanoSeconds, hrtime, loadTime;\n\t\n\t  if ((typeof performance !== \"undefined\" && performance !== null) && performance.now) {\n\t    module.exports = function() {\n\t      return performance.now();\n\t    };\n\t  } else if ((typeof process !== \"undefined\" && process !== null) && process.hrtime) {\n\t    module.exports = function() {\n\t      return (getNanoSeconds() - loadTime) / 1e6;\n\t    };\n\t    hrtime = process.hrtime;\n\t    getNanoSeconds = function() {\n\t      var hr;\n\t      hr = hrtime();\n\t      return hr[0] * 1e9 + hr[1];\n\t    };\n\t    loadTime = getNanoSeconds();\n\t  } else if (Date.now) {\n\t    module.exports = function() {\n\t      return Date.now() - loadTime;\n\t    };\n\t    loadTime = Date.now();\n\t  } else {\n\t    module.exports = function() {\n\t      return new Date().getTime() - loadTime;\n\t    };\n\t    loadTime = new Date().getTime();\n\t  }\n\t\n\t}).call(this);\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\tfunction defaultSetTimout() {\n\t    throw new Error('setTimeout has not been defined');\n\t}\n\tfunction defaultClearTimeout () {\n\t    throw new Error('clearTimeout has not been defined');\n\t}\n\t(function () {\n\t    try {\n\t        if (typeof setTimeout === 'function') {\n\t            cachedSetTimeout = setTimeout;\n\t        } else {\n\t            cachedSetTimeout = defaultSetTimout;\n\t        }\n\t    } catch (e) {\n\t        cachedSetTimeout = defaultSetTimout;\n\t    }\n\t    try {\n\t        if (typeof clearTimeout === 'function') {\n\t            cachedClearTimeout = clearTimeout;\n\t        } else {\n\t            cachedClearTimeout = defaultClearTimeout;\n\t        }\n\t    } catch (e) {\n\t        cachedClearTimeout = defaultClearTimeout;\n\t    }\n\t} ())\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn't available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch(e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch(e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\t\n\t\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn't available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\t\n\t\n\t\n\t}\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar style = document.createElement('p').style,\n\t    prefixes = 'O ms Moz webkit'.split(' '),\n\t    hasPrefix = /^(o|ms|moz|webkit)/,\n\t    upper = /([A-Z])/g,\n\t    memo = {};\n\t\n\tfunction get(key){\n\t    return (key in memo) ? memo[key] : memo[key] = prefix(key);\n\t}\n\t\n\tfunction prefix(key){\n\t    var capitalizedKey = key.replace(/-([a-z])/g, function(s, match){\n\t            return match.toUpperCase();\n\t        }),\n\t        i = prefixes.length,\n\t        name;\n\t\n\t    if (style[capitalizedKey] !== undefined) return capitalizedKey;\n\t\n\t    capitalizedKey = capitalize(key);\n\t\n\t    while (i--) {\n\t        name = prefixes[i] + capitalizedKey;\n\t        if (style[name] !== undefined) return name;\n\t    }\n\t\n\t    throw new Error('unable to prefix ' + key);\n\t}\n\t\n\tfunction capitalize(str){\n\t    return str.charAt(0).toUpperCase() + str.slice(1);\n\t}\n\t\n\tfunction dashedPrefix(key){\n\t    var prefixedKey = get(key),\n\t        upper = /([A-Z])/g;\n\t\n\t    if (upper.test(prefixedKey)) {\n\t        prefixedKey = (hasPrefix.test(prefixedKey) ? '-' : '') + prefixedKey.replace(upper, '-$1');\n\t    }\n\t\n\t    return prefixedKey.toLowerCase();\n\t}\n\t\n\tmodule.exports = get;\n\tmodule.exports.dash = dashedPrefix;\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// Smooth.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 42927a26f9cccab1f143","var raf         = require('raf');\nvar prefix      = require('vendor-prefix');\nvar transform   = prefix.dash('transform');\nvar transition  = prefix.dash('transition');\n\n/*!\n * smooth core\n *\n * Tim Roussilhe\n *\n * Free to use under terms of MIT license\n */\n\n/*!\n\n */\n export default class Smooth {\n\t\t/*\n\t\t * Global api.\n\t\t */\n\n\t\tconstructor() {\n\t\t\t\tthis.VERSION = '0.0.1'\n\n\t\t\t\tvar opt = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n\t\t\t\tthis.handlers = {\n\t\t\t\t\t\trun: null,\n\t\t\t\t\t\tdebounce: null,\n\t\t\t\t\t\tresize: null\n\t\t\t\t};\n\n\t\t\t\tthis.perfs = {\n\t\t\t\t\t\tnow: null,\n\t\t\t\t\t\tlast: null\n\t\t\t\t};\n\n\t\t\t\tthis.vars = {\n\t\t\t\t\t\tpreload : opt.preload || false,\n\t\t\t\t\t\tcurrent : 0,\n\t\t\t\t\t\ttarget : 0,\n\t\t\t\t\t\theight : 0,\n\t\t\t\t\t\tdocumentHeight : 0,\n\t\t\t\t\t\tbounding : 0,\n\t\t\t\t\t\ttimer : null,\n\t\t\t\t\t\tticking : false\n\t\t\t\t};\n\n\n\t\t\t\t//pony trick here, we remove easing on frist frame to avoid flash or blink or big scroll\n\t\t\t\tthis.firstFrame = true;\n\n\t\t\t\tthis.ticketScroll = false;\n\n\t\t\t\tthis.smoothContainer = opt.smoothContainer;\n\n\t\t\t\tif(this.smoothContainer){\n\n\t\t\t\t\t\tthis.smoothSection = {\n\t\t\t\t\t\t\t\tel :  opt.smoothSection ? opt.smoothSection : document.body,\n\t\t\t\t\t\t\t\tanimation :\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\ttransform : [\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttransformType : 'translate3d',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\taxis : 'y',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tease : 0.15,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinitialValue : 0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t//lister is use for smooth scrolling container\n\t\t\t\tthis.dom = document.body;\n\t\t\t\tthis.fakeDiv = null;\n\n\t\t\t\tthis.elementsParallaxe = [];\n\t\t\t\tthis.elementsTrigger = [];\n\n\t\t\t\tthis.resize();\n\n\t\t}\n\n\n\n\t\t\t\tinit(){\n\n\t\t\t\t\t\tthis.vars.preload && this.preloadImages();\n\n\t\t\t\t\t\tthis.addEvents();\n\n\t\t\t\t\t\t!this.vars.preload && this.resize();\n\n\t\t\t\t}\n\n\t\t\t\tstart() {\n\t\t\t\t\t\tthis.reflow();\n\t\t\t\t\t\tthis.raf = raf(this.handlers.run);\n\t\t\t\t}\n\n\t\t\t\taddElement(element){\n\n\t\t\t\t\t\tif(element.animations !== undefined){\n\n\t\t\t\t\t\t\t\tthis.elementsParallaxe.push(element);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(element.trigger !== undefined){\n\n\t\t\t\t\t\t\t\telement.triggered = false;\n\t\t\t\t\t\t\t\tthis.elementsTrigger.push(element);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\taddElements(elements){\n\n\t\t\t\t\t\tfor (var i = 0; i < elements.length; i++) {\n\n\t\t\t\t\t\t\t\tthis.addElement(elements[i]);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t//In case we wanna add dynamic value from the instaciation of the parent resize\n\t\t\t\tresetElements(elements){\n\n\t\t\t\t\t\tthis.elementsParallaxe = [];\n\t\t\t\t\t\tthis.elementsTrigger = [];\n\n\t\t\t\t\t\tthis.addElements(elements);\n\t\t\t\t\t\tthis.reflow();\n\n\t\t\t\t}\n\t\t\t\t//If an object as several transform we need extra work ( thanks you css !)\n\t\t\t\tsetTransformSequence(animation){\n\n\t\t\t\t\t\tanimation.startValue = this.findStart(animation.transform);\n\t\t\t\t\t\tanimation.endValue = this.findEnd(animation.transform);\n\n\t\t\t\t}\n\n\t\t\t\tpreloadImages(){\n\n\t\t\t\t\t\tvar images = Array.prototype.slice.call(this.dom.querySelectorAll('img'), 0);\n\n\t\t\t\t\t\timages.forEach(function (image) {\n\n\t\t\t\t\t\t\t\tvar img = new Image();\n\n\t\t\t\t\t\t\t\timg.onload = function (el) {\n\n\t\t\t\t\t\t\t\t\t\timages.splice(images.indexOf(image), 1);\n\t\t\t\t\t\t\t\t\t\timages.length === 0 && this.resize();\n\n\t\t\t\t\t\t\t\t}.bind(this);\n\n\t\t\t\t\t\t\t\timg.src = image.getAttribute('src');\n\t\t\t\t\t\t}.bind(this));\n\n\t\t\t\t}\n\n\t\t\t\tdebounce(){\n\n\t\t\t\t\t\tthis.ticketScroll = true;\n\n\t\t\t\t}\n\n\t\t\t\taddScrollingClass(){\n\n\t\t\t\t\t\tclearTimeout(this.vars.timer);\n\n\t\t\t\t\t\tif (!this.vars.ticking) {\n\t\t\t\t\t\t\t\tthis.vars.ticking = true;\n\n\t\t\t\t\t\t\t\tthis.dom.classList.add('is-scrolling');\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.vars.timer = setTimeout(function () {\n\t\t\t\t\t\t\t\tthis.vars.ticking = false;\n\n\t\t\t\t\t\t\t\tthis.dom.classList.remove('is-scrolling');\n\n\t\t\t\t\t\t}.bind(this), 200);\n\n\t\t\t\t}\n\t\t\t\trun(){\n\n\t\t\t\t\t\tif( this.ticketScroll ){\n\n\t\t\t\t\t\t\t\tthis.vars.target = window.scrollY || window.pageYOffset;\n\t\t\t\t\t\t\t\tthis.addScrollingClass();\n\t\t\t\t\t\t\t\tthis.ticketScroll = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// this.vars.current += (this.vars.target - this.vars.current) * this.vars.ease;\n\t\t\t\t\t\tthis.vars.current = this.vars.target;\n\t\t\t\t\t\tthis.vars.current < .1 && (this.vars.current = 0);\n\n\t\t\t\t\t\t// If we are having a global smooth container\n\t\t\t\t\t\t// Animate it following scroll position of dom\n\t\t\t\t\t\tif(this.smoothContainer) this.updatesmoothContainer(this.vars.current===this.vars.old);\n\n\n\t\t\t\t\t\t//Still not sure why i pass frame here since we register this globaly...\n\t\t\t\t\t\tthis.updateParallaxeElements(this.vars.current , this.vars.current===this.vars.old );\n\t\t\t\t\t\tif(this.vars.current !=this.vars.old) this.checkTriggerElements(this.vars.current);\n\n\t\t\t\t\t\tthis.vars.old = this.vars.current;\n\n\t\t\t\t\t\t//this.rAF = requestAnimationFrame(this.run.bind(this));\n\t\t\t\t\t\tthis.raf = raf(this.handlers.run);\n\n\t\t\t\t}\n\t\t\t\tupdatesmoothContainer(notScrolling){\n\n\n\t\t\t\t\t\tif( !this.smoothSection.animation.transform[0].done || !notScrolling){\n\n\t\t\t\t\t\t\t\tthis.smoothSection.animation.properties = [];\n\t\t\t\t\t\t\t\t//so far we only allow one transform on the body (x or y)\n\t\t\t\t\t\t\t\tthis.computeTransformStyle(this.smoothSection.animation ,this.smoothSection.animation.transform[0], -this.vars.current);\n\n\t\t\t\t\t\t\t\tthis.setStyle( this.smoothSection.el , this.smoothSection.animation.properties);\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t}\n\t\t\t\t/**\n\t\t\t\t* Update all Elements\n\t\t\t\t* Edge Management\n\t\t\t\t*/\n\t\t\t\tupdateParallaxeElements(frame, notScrolling){\n\n\t\t\t\t\t\tvar index = 0;\n\t\t\t\t\t\tfor(; index < this.elementsParallaxe.length; index++) {\n\n\t\t\t\t\t\t\t\tvar element = this.elementsParallaxe[index];\n\t\t\t\t\t\t\t\tvar properties = [];\n\n\t\t\t\t\t\t\t\tfor (var j = 0; j < element.animations.length; j++) {\n\n\t\t\t\t\t\t\t\t\t\tvar animation = element.animations[j];\n\t\t\t\t\t\t\t\t\t\tvar before = frame < animation.startValue;\n\t\t\t\t\t\t\t\t\t\tvar after = frame > animation.endValue;\n\n\t\t\t\t\t\t\t\t\t\t//create a new array to catch all properties related to the same el\n\t\t\t\t\t\t\t\t\t\tanimation.properties = [];\n\n\t\t\t\t\t\t\t\t\t\t//If we are before/after the first/`last frame, set the styles according first/last value.\n\t\t\t\t\t\t\t\t\t\tif(before || after) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t//we are at firt or last and allready setStyle to reach initial/final Value\n\t\t\t\t\t\t\t\t\t\t\t\tif(before && animation.edge === -1 || after && animation.edge === 1){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(animation.done) continue;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tanimation.edge = before ? -1 : 1;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif(animation.transform){\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//We need to check that all subAnimation are done so we use this as a flag\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar transformDone = true;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var indexTransform = 0; indexTransform < animation.transform.length; indexTransform++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar transformAnimation = animation.transform[indexTransform];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.computeTransformStyle( animation , transformAnimation , animation.edge === -1 ? transformAnimation.initialValue : transformAnimation.finalValue);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif( transformAnimation.done === false ) transformDone = false;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//no we check the flag\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// if one of the subAnimation is not done the flag will be false\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// // if all done then the main animation is done\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif( transformDone === true ){\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tanimation.done = true;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}else{\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tanimation.done = false;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t}else{\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.computeClassicStyle( animation , animation.edge === -1 ? animation.initialValue : animation.finalValue);\n\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t//now we have array of properties we gonna parse them and apply them\n\t\t\t\t\t\t\t\t\t\t\t\tif( animation.properties.length > 0) this.setStyle( element.el ,animation.properties );\n\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\t\t\t\t}else{\n\n\t\t\t\t\t\t\t\t\t\t\t\tif(animation.done && animation.edge ===0 && notScrolling) continue;\n\t\t\t\t\t\t\t\t\t\t\t\tanimation.edge = 0;\n\n\t\t\t\t\t\t\t\t\t\t\t\t//We need to check that all subAnimation are done so we use this as a flag\n\t\t\t\t\t\t\t\t\t\t\t\tvar transformDone = true;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif(animation.transform){\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var indexTransform = 0; indexTransform < animation.transform.length; indexTransform++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar transformAnimation = animation.transform[indexTransform];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Cap progress between 0 and 1 ( Mostly because of transform sequences )\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar progress = Math.min(Math.max((frame - transformAnimation.startValue ) / ( transformAnimation.endValue - transformAnimation.startValue),0), 1);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//TODO ADD EASING\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// progress = left.props[key].easing(progress);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar currentValue =  transformAnimation.initialValue + ((transformAnimation.finalValue - transformAnimation.initialValue) * progress);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.computeTransformStyle(animation,transformAnimation,currentValue);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif( transformAnimation.done === false ) transformDone = false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//no we check the flag\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// if one of the subAnimation is not done the flag will be false\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// if all done then the main animation is done\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif( transformDone === true ){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tanimation.done = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tanimation.done = false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t}else{\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar progress = (frame - animation.startValue ) / ( animation.endValue - animation.startValue);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar currentValue =  animation.initialValue + ((animation.finalValue - animation.initialValue) * progress);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.computeClassicStyle(animation,currentValue);\n\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t// now we have array of properties we gonna parse them and apply them\n\t\t\t\t\t\t\t\t\t\t\t\t// we are doing this one per animation not once per element\n\t\t\t\t\t\t\t\t\t\t\t\tif( animation.properties.length > 0 ) this.setStyle( element.el , animation.properties );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tcheckTriggerElements(frame){\n\n\t\t\t\t\t\tvar index = 0;\n\t\t\t\t\t\tfor(; index < this.elementsTrigger.length; index++) {\n\n\t\t\t\t\t\t\t\tvar element = this.elementsTrigger[index];\n\t\t\t\t\t\t\t\tvar before = frame < element.startValue;\n\n\t\t\t\t\t\t\t\t//add css transition and trigger first position\n\t\t\t\t\t\t\t\tif(!element.isInit){\n\n\t\t\t\t\t\t\t\t\t\tthis.setStyle(element.el,element.transition,true);\n\t\t\t\t\t\t\t\t\t\telement.isInit = true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// So far we are not using after for the trigger\n\t\t\t\t\t\t\t\tif(before) {\n\n\t\t\t\t\t\t\t\t\t\tif(before && element.edge === -1 ) continue;\n\n\t\t\t\t\t\t\t\t\t\telement.edge = before ? -1 : 1;\n\n\t\t\t\t\t\t\t\t\t\t// if we are going back before trigger point\n\t\t\t\t\t\t\t\t\t\t// triggered = false\n\t\t\t\t\t\t\t\t\t\tif(element.trigger.reset){\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0; i < element.initialStyles.length; i++) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.setStyle(element.el,element.initialStyles[i],true);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\telement.triggered = false;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}else if(!element.triggered){\n\n\t\t\t\t\t\t\t\t\t\telement.edge = 0;\n\t\t\t\t\t\t\t\t\t\telement.triggered = true;\n\n\t\t\t\t\t\t\t\t\t\tfor (var i = 0; i < element.finalStyles.length; i++) {\n\t\t\t\t\t\t\t\t\t\t\t\tthis.setStyle(element.el,element.finalStyles[i].style,true);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t//OUTPUT\n\t\t\t\tcomputeTransformStyle(animation,tfAnimation,value){\n\n\t\t\t\t\t\t//We calculate smooth value here if easing\n\t\t\t\t\t\t//here means first fucking frame\n\t\t\t\t\t\tif(tfAnimation.smoothValue === undefined){\n\t\t\t\t\t\t\t\ttfAnimation.smoothValue = tfAnimation.initialValue;\n\t\t\t\t\t\t\t\ttfAnimation.smoothValue += (value - tfAnimation.smoothValue);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\ttfAnimation.smoothValue += ((value - tfAnimation.smoothValue) * tfAnimation.ease);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar roundedValue = Math.round(tfAnimation.smoothValue * 1000)/1000;\n\n\t\t\t\t\t\t//checking if animation of transform value is done\n\t\t\t\t\t\t//check if animation is done comparing the final value to the rounded one\n\t\t\t\t\t\t// we need to round the final value too to be able to compate to roundedValue\n\t\t\t\t\t\tif(Math.round(value * 1000)/1000 === roundedValue) tfAnimation.done = true;\n\t\t\t\t\t\telse tfAnimation.done = false;\n\n\t\t\t\t\t\t//We check if there is allready a transform in the main animation\n\t\t\t\t\t\tif(animation.properties){\n\n\t\t\t\t\t\t\t\tfor (var i = 0; i < animation.properties.length; i++) {\n\n\t\t\t\t\t\t\t\t\t\t//Case for transform\n\t\t\t\t\t\t\t\t\t\tif(animation.properties[i].property === tfAnimation.transformType){\n\n\t\t\t\t\t\t\t\t\t\t\t\tanimation.properties[i][tfAnimation.axis] = roundedValue;\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//If there is no transform we create the object\n\t\t\t\t\t\tvar style = {\n\t\t\t\t\t\t\t\tproperty : tfAnimation.transformType\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tstyle[tfAnimation.axis] = roundedValue;\n\n\t\t\t\t\t\t//push value to parent animation\n\t\t\t\t\t\tanimation.properties.push(style);\n\t\t\t\t}\n\n\t\t\t\tcomputeClassicStyle( animation , value ){\n\n\t\t\t\t\t\t//We calculate smooth value here if easing\n\t\t\t\t\t\t//here means first fucking frame so no easing to avoid blick/flash etc\n\t\t\t\t\t\tif(animation.smoothValue === undefined){\n\t\t\t\t\t\t\t\tanimation.smoothValue = animation.initialValue;\n\t\t\t\t\t\t\t\tanimation.smoothValue += (value - animation.smoothValue);\n\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tanimation.smoothValue += ((value - animation.smoothValue) * animation.ease);\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tvar roundedValue = Math.round(animation.smoothValue * 100)/100;\n\n\t\t\t\t\t\tvar style = {\n\t\t\t\t\t\t\t\tproperty : animation.property,\n\t\t\t\t\t\t\t\tvalue : roundedValue\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t//check if animation is done comparing the final value to the rounded one\n\t\t\t\t\t\t// we need to round the final value too to be able to compate to roundedValue\n\t\t\t\t\t\tif(Math.round(value * 100)/100 === roundedValue) animation.done = true;\n\t\t\t\t\t\telse animation.done = false;\n\n\t\t\t\t\t\t//save property into animation object\n\t\t\t\t\t\tanimation.properties.push(style);\n\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t* Set Future Style\n\t\t\t\t* Element is here to pass el of current Element\n\t\t\t\t* Animation is current animation of element ( need to be precised because it can be several ones )\n\t\t\t\t* Value is current scroll value ( need to be calculated before ) Here we just apply momemtum is ease < 1\n\t\t\t\t*/\n\t\t\t\t//rounded number\n\t\t\t\t//https://jsperf.com/parsefloat-tofixed-vs-math-round\n\n\t\t\t\tsetStyle( el , style , noParsing ){\n\n\t\t\t\t\t\tif(!noParsing) var style = this.parseStyle( style );\n\n\t\t\t\t\t\tif(style[0]==='transform'){\n\t\t\t\t\t\t\t\tel.style[transform] = style[1];\n\t\t\t\t\t\t}else if(style[0]==='opacity'){\n\t\t\t\t\t\t\t\tel.style.opacity = style[1];\n\t\t\t\t\t\t}else if(style[0]==='transition'){\n\t\t\t\t\t\t\t\tel.style[transition] = style[1];\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// return an object containing all style\n\t\t\t\t// ====>\n\t\t\t\t// Example Object {transform: \"translate3d(66.5px,66.5px,0) scale3d(1.06,1.06,1)\"}\n\t\t\t\t// ====>\n\t\t\t\tparseStyle(properties){\n\t\t\t\t\t\t// could use regexpt and a pattern here but want to avoid replace inside raf\n\t\t\t\t\t\t// so we chose switch and string concatenation\n\t\t\t\t\t\t// also useful if we want to add more control here such as translate or translate3d... background color calculcation etc\n\t\t\t\t\t\t// https://jsperf.com/string-concat-vs-regex-replace/2\n\n\t\t\t\t\t\t//TODO Centralize Animations when severals animations and at the end set all style\n\t\t\t\t\t\t// AND return all\n\t\t\t\t\t\tvar parsedStyle = [];\n\n\t\t\t\t\t\tfor (var i = 0; i < properties.length; i++) {\n\n\t\t\t\t\t\t\t\tvar currentProperty = properties[i];\n\t\t\t\t\t\t\t\tswitch(currentProperty.property) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'translate3d':\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = currentProperty.x ? currentProperty.x+'px' : 0;\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = currentProperty.y ? currentProperty.y+'px' : 0;\n\t\t\t\t\t\t\t\t\t\t\t\tvar z = currentProperty.z ? currentProperty.z+'px' : 0;\n\n\t\t\t\t\t\t\t\t\t\t\t //parsedStyle['transform'] ? parsedStyle['transform'] += ' translate3d('+ x +','+ y +','+ z +')' : parsedStyle[\"transform\"] = 'translate3d('+ x +','+ y +','+ z +')';\n\t\t\t\t\t\t\t\t\t\t\t if(parsedStyle[0]==='transform'){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparsedStyle[1] += ' translate3d('+ x +','+ y +','+ z +')'\n\t\t\t\t\t\t\t\t\t\t\t }else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparsedStyle[0] = 'transform';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparsedStyle[1] = 'translate3d('+ x +','+ y +','+ z +')'\n\t\t\t\t\t\t\t\t\t\t\t }\n\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase 'scale3d':\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = currentProperty.x || currentProperty.both ? currentProperty.x || currentProperty.both : 1;\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = currentProperty.y || currentProperty.both ? currentProperty.y || currentProperty.both : 1;\n\t\t\t\t\t\t\t\t\t\t\t\tvar z = currentProperty.z ? currentProperty.z+'px' : 1;\n\n\t\t\t\t\t\t\t\t\t\t\t\t//parsedStyle[\"transform\"] ?  parsedStyle[\"transform\"] += ' scale3d('+ x +','+ y +','+ z +')' : parsedStyle[\"transform\"] = 'scale3d('+ x +','+ y +','+ z +')'\n\t\t\t\t\t\t\t\t\t\t\t\tif(parsedStyle[0]==='transform'){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparsedStyle[1] += ' scale3d('+ x +','+ y +','+ z +')'\n\t\t\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparsedStyle[0] = 'transform';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparsedStyle[1] = 'scale3d('+ x +','+ y +','+ z +')'\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase 'rotate3d':\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = currentProperty.x || currentProperty.both ? currentProperty.x || currentProperty.both : 1;\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = currentProperty.y || currentProperty.both ? currentProperty.y || currentProperty.both : 1;\n\t\t\t\t\t\t\t\t\t\t\t\tvar z = currentProperty.z ? currentProperty.z+'px' : 1;\n\n\t\t\t\t\t\t\t\t\t\t\t\t//parsedStyle[\"transform\"] = parsedStyle[\"transform\"] = 'rotate('+currentProperty.y+'deg)'\n\t\t\t\t\t\t\t\t\t\t\t\tif(parsedStyle[0]==='transform'){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparsedStyle[1] += ' rotate('+ x +','+ y +','+ z +')'\n\t\t\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparsedStyle[0] = 'transform';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparsedStyle[1] = 'rotate('+ x +','+ y +','+ z +')'\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase 'opacity':\n\n\t\t\t\t\t\t\t\t\t\t\t\tif(parsedStyle.length > 0){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparsedStyle.push('opacity');\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparsedStyle.push(currentProperty.value);\n\t\t\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparsedStyle[0] = 'opacity';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparsedStyle[1] = currentProperty.value;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn parsedStyle;\n\n\t\t\t\t}\n\t\t\t\tgenerateTransition(elem) {\n\n\t\t\t\t\t\tvar transition = [];\n\t\t\t\t\t\ttransition[0] = 'transition';\n\t\t\t\t\t\ttransition[1] = '';\n\n\t\t\t\t\t\t//We decided to check final styles value to add proper properties ( also initial state can be set in CSS too)\n\t\t\t\t\t\tfor (var i = 0; i < elem.finalStyles.length; i++) {\n\n\t\t\t\t\t\t\t\tvar finalStyle = elem.finalStyles[i];\n\t\t\t\t\t\t\t\ttransition[1] += finalStyle.style[0]+' '+ finalStyle.duration / 1000 + 's '+finalStyle.easing+' '+finalStyle.delay / 1000 + 's';\n\n\t\t\t\t\t\t\t\tif(i != elem.finalStyles.length - 1){\n\t\t\t\t\t\t\t\t\t\ttransition[1] += ' , ';\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn transition;\n\n\t\t\t\t}\n\n\t\t\t\taddEvents(){\n\n\t\t\t\t\t\tconsole.log('addEvents this.handlers',this.handlers);\n\n\t\t\t\t\t\tthis.handlers.debounce   = this.debounce.bind(this);\n\t\t\t\t\t\t//this.handlers.resize     = this.resize.bind(this);\n\t\t\t\t\t\tthis.handlers.run        = this.run.bind(this);\n\n\t\t\t\t\t\twindow.addEventListener('scroll', this.handlers.debounce);\n\t\t\t\t\t\t//window.addEventListener('resize', this.handlers.resize);\n\n\t\t\t\t}\n\t\t\t\tremoveEvents(){\n\n\t\t\t\t\t\tconsole.log('removeEvents this.handlers',this.handlers);\n\n\t\t\t\t\t\twindow.removeEventListener('scroll', this.handlers.debounce);\n\t\t\t\t\t\t//window.removeEventListener('resize', this.handlers.resize);\n\n\t\t\t\t\t\traf.cancel(this.raf);\n\n\t\t\t\t\t\tthis.handlers = {\n\t\t\t\t\t\t\t\trun: null,\n\t\t\t\t\t\t\t\tdebounce: null,\n\t\t\t\t\t\t\t\tresize: null\n\t\t\t\t\t\t};\n\n\t\t\t\t}\n\t\t\t\tremoveFakeScrollHeight(){\n\n\t\t\t\t\t\tthis.fakeDiv.parentNode.removeChild(this.fakeDiv);\n\t\t\t\t\t\tthis.fakeDiv = null;\n\n\t\t\t\t\t\tthis.smoothSection.el.style.position = \"relative\";\n\t\t\t\t\t\tthis.smoothSection.el.style.width = \"auto\";\n\t\t\t\t\t\tthis.smoothSection.el.style.transform = \"\";\n\n\t\t\t\t}\n\t\t\t\taddFakeScrollHeight(value){\n\n\t\t\t\t\t\tif(this.fakeDiv === null){\n\n\t\t\t\t\t\t\t\tthis.fakeDiv = document.createElement(\"div\");\n\t\t\t\t\t\t\t\tthis.fakeDiv.className = \"smooth-fake-scroll\";\n\t\t\t\t\t\t\t\tthis.fakeDiv.style.height = value+\"px\";\n\n\t\t\t\t\t\t\t\tthis.smoothSection.el.parentNode.insertBefore(this.fakeDiv, this.smoothSection.el.nextSibling);\n\t\t\t\t\t\t}else{\n\n\t\t\t\t\t\t\t\tthis.fakeDiv.style.height = value+\"px\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.smoothSection.el.style.position = \"fixed\";\n\t\t\t\t\t\tthis.smoothSection.el.style.width = \"100%\";\n\n\t\t\t\t}\n\t\t\t\taddFakeHeight(value){\n\n\t\t\t\t\t\tthis.dom.style.height = value + 'px';\n\n\t\t\t\t}\n\t\t\t\tremoveFakeHeight(){\n\n\t\t\t\t\t\tthis.dom.style.height = 'auto';\n\n\t\t\t\t}\n\t\t\t\tscrollTo(value){\n\n\t\t\t\t\t\t//TODO ADD COOL SCROLLING AND EASING\n\n\t\t\t\t}\n\n\t\t\t\tgetOffset(el){\n\n\t\t\t\t\t\tvar bodyRect    = this.dom.getBoundingClientRect(),\n\t\t\t\t\t\telemRect        = el.getBoundingClientRect(),\n\t\t\t\t\t\toffset          = elemRect.top - bodyRect.top;\n\n\t\t\t\t\t\treturn offset;\n\n\t\t\t\t}\n\n\t\t\t\t//here we receive the actual DOM element and the animation\n\t\t\t\tgetPositionStart(el , animation){\n\n\t\t\t\t\t\tif(animation.start === 'in-viewport'){\n\n\t\t\t\t\t\t\t\tvar offset = this.getOffset(el);\n\t\t\t\t\t\t\t\tvar elementHeight = el.offsetHeight;\n\t\t\t\t\t\t\t\tvar windowHeight = this.vars.height;\n\n\t\t\t\t\t\t\t\tvar factor = animation.viewFactorStart ? animation.viewFactorStart : 0;\n\n\t\t\t\t\t\t\t\tif( isNaN(factor) && factor.indexOf('px') !== -1 ){\n\t\t\t\t\t\t\t\t\t\tvar positionTop = offset - windowHeight + parseInt(animation.viewFactorStart, 10);\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tvar positionTop = offset - windowHeight + (elementHeight * factor);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn positionTop > 0 ? positionTop : 0;\n\n\t\t\t\t\t\t}else{\n\n\t\t\t\t\t\t\t\treturn animation.start;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgetPositionEnd( el , animation ){\n\n\t\t\t\t\t\tif(animation.end==='out-viewport'){\n\n\t\t\t\t\t\t\t\tvar offset = this.getOffset(el);\n\t\t\t\t\t\t\t\tvar elementHeight = el.offsetHeight;\n\t\t\t\t\t\t\t\tvar factor = animation.viewFactorEnd ? animation.viewFactorEnd : 0;\n\n\t\t\t\t\t\t\t\tvar positionBottom = offset + elementHeight - (elementHeight * factor);\n\n\t\t\t\t\t\t\t\treturn positionBottom > this.vars.documentHeight - this.vars.height ? this.vars.documentHeight - this.vars.height : positionBottom;\n\n\t\t\t\t\t\t}else{\n\n\t\t\t\t\t\t\t\treturn animation.end;\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\t\t\t\tfindStart(array){\n\t\t\t\t\t\tvar min = Number.MAX_VALUE,\n\t\t\t\t\t\t\ta = array.length,\n\t\t\t\t\t\t\tcounter\n\n\t\t\t\t\t\tfor (counter=0;counter<a;counter++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (array[counter].startValue < min)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tmin = array[counter].startValue\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn min\n\t\t\t\t}\n\n\t\t\t\tfindEnd(array){\n\t\t\t\t\t\tvar max = 0,\n\t\t\t\t\t\t\ta = array.length,\n\t\t\t\t\t\t\tcounter\n\n\t\t\t\t\t\tfor (counter=0;counter<a;counter++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (array[counter].endValue > max)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tmax = array[counter].endValue\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn max\n\t\t\t\t}\n\n\t\t\t\tgetDocumentHeight(){\n\n\t\t\t\t\t\tvar body = this.dom,\n\t\t\t\t\t\thtml = document.documentElement;\n\n\t\t\t\t\t\treturn Math.max( body.scrollHeight, body.offsetHeight,\n\t\t\t\t\t\t\t\t\t\t\t html.clientHeight, html.scrollHeight, html.offsetHeight );\n\n\t\t\t\t}\n\n\t\t\t\t//Here we check all element and set their data correctly\n\t\t\t\t//Mostly usefull to parse viewport relative timeline\n\t\t\t\treflow(){\n\n\t\t\t\t\t\tvar end = 0;\n\n\t\t\t\t\t\tfor (var i = 0; i < this.elementsParallaxe.length; i++) {\n\n\t\t\t\t\t\t\t\tvar element = this.elementsParallaxe[i];\n\n\t\t\t\t\t\t\t\tfor (var j = 0; j < element.animations.length; j++) {\n\n\n\t\t\t\t\t\t\t\t\t\tvar animation = element.animations[j];\n\n\t\t\t\t\t\t\t\t\t\t//now we check for transform animations array\n\t\t\t\t\t\t\t\t\t\tif( animation.transform ){\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var l = 0; l < animation.transform.length; l++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//start for each transfor of the array\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tanimation.transform[l].startValue = this.getPositionStart( element.el ,  animation.transform[l]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tanimation.transform[l].endValue = this.getPositionEnd( element.el ,  animation.transform[l]);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t}else{\n\n\t\t\t\t\t\t\t\t\t\t\t\tanimation.startValue = this.getPositionStart( element.el , animation );\n\t\t\t\t\t\t\t\t\t\t\t\tanimation.endValue = this.getPositionEnd( element.el ,  animation);\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t//we build global sequence if there is a timeline of transform\n\t\t\t\t\t\t\t\t\t\tif( animation.transform ) this.setTransformSequence(animation);\n\n\t\t\t\t\t\t\t\t\t\tif(animation.endValue > end) end = animation.endValue;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (var k = 0; k < this.elementsTrigger.length; k++) {\n\n\t\t\t\t\t\t\t\tvar element = this.elementsTrigger[k];\n\n\t\t\t\t\t\t\t\t//here we convert viewport to actual scrolling value if needed\n\n\t\t\t\t\t\t\t\t//TODO IMPROVE THIS FOR TRIGGER\n\t\t\t\t\t\t\t\telement.startValue = this.getPositionStart( element.el , element.trigger);\n\n\t\t\t\t\t\t\t\t//we need also to define initial and final values here\n\t\t\t\t\t\t\t\t//since we just need to applicate them when we reache trigger Y Value\n\n\t\t\t\t\t\t\t\t//Can be optional if set in CSS\n\t\t\t\t\t\t\t\tif(element.trigger.initialValues){\n\t\t\t\t\t\t\t\t\t\telement.initialStyles = [];\n\n\t\t\t\t\t\t\t\t\t\tfor (var i = 0; i < element.trigger.initialValues.length; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar value = element.trigger.initialValues[i];\n\n\t\t\t\t\t\t\t\t\t\t\t\telement.initialStyles.push(this.parseStyle(value.animation));\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t//those are required\n\t\t\t\t\t\t\t\telement.finalStyles = [];\n\n\t\t\t\t\t\t\t\tfor (var i = 0; i < element.trigger.finalValues.length; i++) {\n\n\t\t\t\t\t\t\t\t\t\tvar value = element.trigger.finalValues[i];\n\n\t\t\t\t\t\t\t\t\t\tvar animationObject = {\n\t\t\t\t\t\t\t\t\t\t\t\tdelay : value.delay,\n\t\t\t\t\t\t\t\t\t\t\t\tduration : value.duration,\n\t\t\t\t\t\t\t\t\t\t\t\teasing  : value.easing,\n\t\t\t\t\t\t\t\t\t\t\t\tstyle : this.parseStyle(value.animation),\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telement.finalStyles.push(animationObject);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\telement.transition  = this.generateTransition( element );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//check to initiate first state if needed\n\t\t\t\t\t\tif(this.elementsTrigger.length > 0 ) this.checkTriggerElements(this.vars.current);\n\n\t\t\t\t\t\t// Now we computed all start and end of each animation\n\t\t\t\t\t\t// we checked if need to add more scroll to be sure that we can display them all.\n\t\t\t\t\t\tif(this.smoothContainer){\n\n\t\t\t\t\t\t\t\tvar prop = 'height';\n\t\t\t\t\t\t\t\tthis.vars.bounding = this.smoothSection.el.getBoundingClientRect().height;\n\t\t\t\t\t\t\t\tthis.addFakeScrollHeight(this.vars.bounding);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif( end > this.vars.documentHeight ) this.addFakeHeight(end);\n\n\t\t\t\t}\n\n\t\t\t\tresize(){\n\n\t\t\t\t\t\tthis.vars.height = document.documentElement.clientHeight || window.innerHeight;\n\t\t\t\t\t\tthis.vars.width = document.documentElement.clientWidth || window.innerWidth;\n\t\t\t\t\t\tthis.vars.documentHeight = this.getDocumentHeight();\n\t\t\t\t\t\tthis.reflow();\n\n\t\t\t\t}\n\n\t\t\t\tdestroy(){\n\n\t\t\t\t\t\tif(this.fakeDiv) this.removeFakeScrollHeight();\n\t\t\t\t\t\tthis.removeFakeHeight();\n\t\t\t\t\t\tthis.removeEvents();\n\n\t\t\t\t\t\tthis.elementsTrigger.length = 0;\n\t\t\t\t\t\tthis.elementsTrigger = [];\n\n\t\t\t\t\t\tthis.elementsParallaxe.length = 0;\n\t\t\t\t\t\tthis.elementsParallaxe = [];\n\n\t\t\t\t}\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/smooth.js","var now = require('performance-now')\n  , root = typeof window === 'undefined' ? global : window\n  , vendors = ['moz', 'webkit']\n  , suffix = 'AnimationFrame'\n  , raf = root['request' + suffix]\n  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]\n\nfor(var i = 0; !raf && i < vendors.length; i++) {\n  raf = root[vendors[i] + 'Request' + suffix]\n  caf = root[vendors[i] + 'Cancel' + suffix]\n      || root[vendors[i] + 'CancelRequest' + suffix]\n}\n\n// Some versions of FF have rAF but not cAF\nif(!raf || !caf) {\n  var last = 0\n    , id = 0\n    , queue = []\n    , frameDuration = 1000 / 60\n\n  raf = function(callback) {\n    if(queue.length === 0) {\n      var _now = now()\n        , next = Math.max(0, frameDuration - (_now - last))\n      last = next + _now\n      setTimeout(function() {\n        var cp = queue.slice(0)\n        // Clear queue here to prevent\n        // callbacks from appending listeners\n        // to the current frame's queue\n        queue.length = 0\n        for(var i = 0; i < cp.length; i++) {\n          if(!cp[i].cancelled) {\n            try{\n              cp[i].callback(last)\n            } catch(e) {\n              setTimeout(function() { throw e }, 0)\n            }\n          }\n        }\n      }, Math.round(next))\n    }\n    queue.push({\n      handle: ++id,\n      callback: callback,\n      cancelled: false\n    })\n    return id\n  }\n\n  caf = function(handle) {\n    for(var i = 0; i < queue.length; i++) {\n      if(queue[i].handle === handle) {\n        queue[i].cancelled = true\n      }\n    }\n  }\n}\n\nmodule.exports = function(fn) {\n  // Wrap in a new function to prevent\n  // `cancel` potentially being assigned\n  // to the native rAF function\n  return raf.call(root, fn)\n}\nmodule.exports.cancel = function() {\n  caf.apply(root, arguments)\n}\nmodule.exports.polyfill = function() {\n  root.requestAnimationFrame = raf\n  root.cancelAnimationFrame = caf\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raf/index.js\n// module id = 1\n// module chunks = 0","// Generated by CoffeeScript 1.7.1\n(function() {\n  var getNanoSeconds, hrtime, loadTime;\n\n  if ((typeof performance !== \"undefined\" && performance !== null) && performance.now) {\n    module.exports = function() {\n      return performance.now();\n    };\n  } else if ((typeof process !== \"undefined\" && process !== null) && process.hrtime) {\n    module.exports = function() {\n      return (getNanoSeconds() - loadTime) / 1e6;\n    };\n    hrtime = process.hrtime;\n    getNanoSeconds = function() {\n      var hr;\n      hr = hrtime();\n      return hr[0] * 1e9 + hr[1];\n    };\n    loadTime = getNanoSeconds();\n  } else if (Date.now) {\n    module.exports = function() {\n      return Date.now() - loadTime;\n    };\n    loadTime = Date.now();\n  } else {\n    module.exports = function() {\n      return new Date().getTime() - loadTime;\n    };\n    loadTime = new Date().getTime();\n  }\n\n}).call(this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/performance-now/lib/performance-now.js\n// module id = 2\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 3\n// module chunks = 0","'use strict';\n\nvar style = document.createElement('p').style,\n    prefixes = 'O ms Moz webkit'.split(' '),\n    hasPrefix = /^(o|ms|moz|webkit)/,\n    upper = /([A-Z])/g,\n    memo = {};\n\nfunction get(key){\n    return (key in memo) ? memo[key] : memo[key] = prefix(key);\n}\n\nfunction prefix(key){\n    var capitalizedKey = key.replace(/-([a-z])/g, function(s, match){\n            return match.toUpperCase();\n        }),\n        i = prefixes.length,\n        name;\n\n    if (style[capitalizedKey] !== undefined) return capitalizedKey;\n\n    capitalizedKey = capitalize(key);\n\n    while (i--) {\n        name = prefixes[i] + capitalizedKey;\n        if (style[name] !== undefined) return name;\n    }\n\n    throw new Error('unable to prefix ' + key);\n}\n\nfunction capitalize(str){\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nfunction dashedPrefix(key){\n    var prefixedKey = get(key),\n        upper = /([A-Z])/g;\n\n    if (upper.test(prefixedKey)) {\n        prefixedKey = (hasPrefix.test(prefixedKey) ? '-' : '') + prefixedKey.replace(upper, '-$1');\n    }\n\n    return prefixedKey.toLowerCase();\n}\n\nmodule.exports = get;\nmodule.exports.dash = dashedPrefix;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vendor-prefix/index.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}